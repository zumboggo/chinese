<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Parallel Text Reader (Single File)</title>
<style>
  :root {
    --bg: #f0f4ff;
    --card: #ffffff;
    --primary: #1d4ed8;
    --text: #111827;
    --muted: #6b7280;
    --shadow: 0 6px 18px rgba(0,0,0,0.08);
    --radius: 14px;
  }
  * { box-sizing: border-box; }
  body {
    margin: 0; padding: 0.75rem;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    background: var(--bg); color: var(--text);
  }
  header {
    background: linear-gradient(135deg, var(--primary), #3b82f6);
    color: #fff; text-align: center;
    padding: 0.8rem 1rem; border-radius: var(--radius);
    box-shadow: var(--shadow);
    font-weight: 700; letter-spacing: 0.2px;
  }
  .wrap {
    max-width: 800px; margin: 0.8rem auto; display: grid; gap: 0.9rem;
  }
  .card {
    background: var(--card); border-radius: var(--radius); box-shadow: var(--shadow);
    padding: 0.9rem;
  }
  .row { display: grid; gap: 0.6rem; }
  @media (min-width: 560px){
    .row-cols { grid-template-columns: 1fr 1fr; gap: 0.6rem; }
  }
  label { font-size: 0.9rem; color: var(--muted); }
  input[type="text"], select, button {
    width: 100%; font-size: 1rem; padding: 0.7rem 0.8rem;
    border: 1px solid #e5e7eb; border-radius: 12px; background: #fff;
  }
  input[type="file"]{ font-size: 0.95rem; }
  button.primary {
    background: var(--primary); color: #fff; border: none; font-weight: 600;
  }
  button.ghost { background: #fff; border: 1px solid #e5e7eb; color: #111827; }
  button:active { transform: translateY(1px); }
  .help { font-size: 0.85rem; color: var(--muted); }
  .stack { display: grid; gap: 0.5rem; }
  .reader {
    display: grid; gap: 0.75rem;
  }
  .pane {
    background: #fff; border-radius: 12px; padding: 0.9rem;
    overflow-y: auto; box-shadow: inset 0 0 0 1px #f1f5f9;
    white-space: pre-wrap; line-height: 1.6;
  }
  /* Taller pane for English with scrolling */
  #englishDisplay { max-height: 70vh; }
  .toolbar {
    display: grid; gap: 0.5rem;
  }
  @media (min-width: 560px){
    .toolbar { grid-template-columns: 1fr auto auto; align-items: end; }
  }
  .pill {
    display: inline-flex; align-items: center; gap: 0.5rem;
    padding: 0.5rem 0.65rem; border-radius: 999px; background: #f3f4f6; color: #374151;
    font-size: 0.85rem;
  }
</style>
</head>
<body>
  <header>ðŸ“– Parallel Text Reader</header>
  <div class="wrap">

    <!-- CSV Loader & Two-Level Selection -->
    <section class="card row">
      <div class="row row-cols">
        <div class="stack">
          <label for="csvInput">Add CSV (Col1=Chinese, Col2=English, Col3=Title)</label>
          <input id="csvInput" type="file" accept=".csv" />
          <div class="help">You can add multiple CSVs. Each row becomes a story. Only the Title (col 3) shows in the story list.</div>
        </div>
        <div class="stack">
          <label>CSV Files</label>
          <select id="fileSelector" disabled>
            <option value="">â€” No CSV loaded â€”</option>
          </select>
        </div>
      </div>
      <div class="row">
        <div class="stack">
          <label>Stories in Selected CSV (by Title)</label>
          <select id="storySelector" disabled>
            <option value="">â€” Select a CSV first â€”</option>
          </select>
        </div>
      </div>
      <div class="row row-cols">
        <button id="clearAll" class="ghost">Clear All CSVs</button>
        <span class="pill" id="statusPill">0 files â€¢ 0 stories</span>
      </div>
    </section>

    <!-- Quick manual paste (one line) -->
    <section class="card row">
      <div class="row row-cols">
        <div class="stack">
          <label for="englishInput">Quick English (one line)</label>
          <input id="englishInput" type="text" placeholder="Paste English here"/>
        </div>
        <div class="stack">
          <label for="chineseInput">Quick Chinese (one line)</label>
          <input id="chineseInput" type="text" placeholder="ç²˜è´´ä¸­æ–‡åœ¨è¿™é‡Œ"/>
        </div>
      </div>
      <div class="row row-cols">
        <button id="loadManual" class="primary">Load Text</button>
        <div class="stack">
          <label><input type="checkbox" id="autoTTS" checked /> Auto Chinese TTS</label>
        </div>
      </div>
    </section>

    <!-- Reader panes & audio controls -->
    <section class="card row">
      <div class="toolbar">
        <div class="pill" id="nowReading">Now reading: â€”</div>
        <button id="replayZH" class="ghost">Replay Chinese</button>
        <button id="stopAll" class="ghost">Stop Audio</button>
      </div>
      <div class="reader">
        <div class="pane" id="englishDisplay" aria-label="English text"></div>
      </div>
    </section>

  </div>

<script>
/* ========= Data Structures ========= */
const datasets = new Map(); // key: fileName, value: {fileName, stories: [{title, english, chinese}]}
const fileSelector = document.getElementById('fileSelector');
const storySelector = document.getElementById('storySelector');
const statusPill = document.getElementById('statusPill');
const nowReading = document.getElementById('nowReading');

const englishDisplay = document.getElementById('englishDisplay');
let currentChinese = '';

const englishInput = document.getElementById('englishInput');
const chineseInput = document.getElementById('chineseInput');
const autoTTS = document.getElementById('autoTTS');

const csvInput = document.getElementById('csvInput');
const loadManualBtn = document.getElementById('loadManual');
const clearAllBtn = document.getElementById('clearAll');
const replayZHBtn = document.getElementById('replayZH');
const stopAllBtn = document.getElementById('stopAll');

/* ========= CSV Parsing (handles quotes) ========= */
function parseCSV(text) {
  const rows = [];
  let i = 0, field = '', row = [], inQuotes = false;

  // Normalize newlines
  text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');

  while (i < text.length) {
    const char = text[i];

    if (inQuotes) {
      if (char === '"') {
        // Possible end of quoted field or escaped quote
        if (text[i+1] === '"') { field += '"'; i += 2; continue; }
        inQuotes = false; i++; continue;
      } else {
        field += char; i++; continue;
      }
    } else {
      if (char === '"') {
        inQuotes = true; i++; continue;
      } else if (char === ',') {
        row.push(field); field=''; i++; continue;
      } else if (char === '\n') {
        row.push(field); field=''; rows.push(row); row=[]; i++; continue;
      } else {
        field += char; i++; continue;
      }
    }
  }
  // last field/row
  row.push(field);
  rows.push(row);
  return rows;
}

/* ========= File Handling ========= */
csvInput.addEventListener('change', async (e) => {
  const file = e.target.files?.[0];
  if (!file) return;

  const fileName = file.name;
  const text = await file.text();
  const rows = parseCSV(text);

  // Turn each row into a story: [0]=Chinese, [1]=English, [2]=Title
  const stories = [];
  for (let idx=0; idx<rows.length; idx++){
    const r = rows[idx];
    if (!r || r.length < 3) continue;

    // strip BOM from first cell if present
    if (idx===0 && r[0] && r[0].charCodeAt(0) === 0xFEFF) {
      r[0] = r[0].slice(1);
    }

    const chinese = (r[0] ?? '').trim();
    const english = (r[1] ?? '').trim();
    const title = ((r[2] ?? '').trim()) || `Story ${idx+1}`;

    // skip completely empty rows
    if (!chinese && !english && !title) continue;

    stories.push({ title, english, chinese });
  }

  datasets.set(fileName, { fileName, stories });
  updateFileSelector();
  // Auto-select the newly added file
  fileSelector.value = fileName;
  populateStorySelector();
  updateStatus();
  csvInput.value = ''; // reset input
});

function updateFileSelector(){
  const prevValue = fileSelector.value;
  fileSelector.innerHTML = '';
  if (datasets.size === 0) {
    fileSelector.disabled = true;
    fileSelector.innerHTML = '<option value="">â€” No CSV loaded â€”</option>';
    storySelector.disabled = true;
    storySelector.innerHTML = '<option value="">â€” Select a CSV first â€”</option>';
    return;
  }
  fileSelector.disabled = false;
  for (const key of datasets.keys()) {
    const opt = document.createElement('option');
    opt.value = key;
    opt.textContent = key;
    fileSelector.appendChild(opt);
  }
  if (datasets.has(prevValue)) fileSelector.value = prevValue;
}

fileSelector.addEventListener('change', () => {
  populateStorySelector();
  updateStatus();
});

function populateStorySelector(){
  const key = fileSelector.value;
  const ds = datasets.get(key);
  storySelector.innerHTML = '';
  if (!ds || !ds.stories?.length) {
    storySelector.disabled = true;
    storySelector.innerHTML = '<option value="">â€” No stories in this CSV â€”</option>';
    return;
  }
  storySelector.disabled = false;
  // Only show titles
  ds.stories.forEach((s, i) => {
    const opt = document.createElement('option');
    opt.value = i.toString();
    opt.textContent = s.title || `Story ${i+1}`;
    storySelector.appendChild(opt);
  });
}

storySelector.addEventListener('change', () => {
  const key = fileSelector.value;
  const ds = datasets.get(key);
  const idx = parseInt(storySelector.value, 10);
  if (!ds || Number.isNaN(idx)) return;
  const story = ds.stories[idx];
  displayStory(story, `${ds.fileName} â€¢ ${story.title}`);
  if (autoTTS.checked) speakChinese(story.chinese);
  updateStatus();
});

clearAllBtn.addEventListener('click', () => {
  datasets.clear();
  updateFileSelector();
  updateStatus();
  englishDisplay.textContent = '';
  currentChinese = '';
  nowReading.textContent = 'Now reading: â€”';
  stopSpeaking();
});

/* ========= Manual Load ========= */
loadManualBtn.addEventListener('click', () => {
  const eng = englishInput.value ?? '';
  const chi = chineseInput.value ?? '';
  displayStory({ english: eng, chinese: chi, title: '(Manual)' }, '(Manual)');
  if (autoTTS.checked) speakChinese(chi);
});

/* ========= Display ========= */
function displayStory(story, label){
  englishDisplay.textContent = story.english || '';
  currentChinese = story.chinese || '';
  nowReading.textContent = `Now reading: ${label || (story.title ?? 'â€”')}`;
  // scroll to top each time
  englishDisplay.scrollTop = 0;
}

/* ========= TTS ========= */
let voices = [];
let zhVoice = null;

function loadVoices(){
  return new Promise(resolve => {
    const handler = () => {
      voices = speechSynthesis.getVoices();
      zhVoice = pickVoice(['zh-CN','zh-TW','zh']);
      resolve();
    };
    speechSynthesis.onvoiceschanged = handler;
    // in some browsers voices are ready immediately
    handler();
    // fallback timeout
    setTimeout(handler, 400);
  });
}

function pickVoice(preferredLangs){
  const v = speechSynthesis.getVoices();
  // best match by startsWith
  for (const lang of preferredLangs){
    const match = v.find(x => (x.lang || '').toLowerCase().startsWith(lang.toLowerCase()));
    if (match) return match;
  }
  // fallback to any Chinese voice
  return v.find(x => (x.lang || '').toLowerCase().startsWith('zh')) || null;
}

function speak(text, lang, voice){
  if (!('speechSynthesis' in window) || !text) return null;
  const u = new SpeechSynthesisUtterance(text);
  if (voice) u.voice = voice;
  u.lang = lang;
  speechSynthesis.speak(u);
  return u;
}

function stopSpeaking(){
  if (!('speechSynthesis' in window)) return;
  speechSynthesis.cancel();
}

async function speakChinese(chinese){
  if (!('speechSynthesis' in window)) return;
  stopSpeaking();
  await loadVoices();

  return new Promise(resolve => {
    const zhUtter = speak(chinese, (zhVoice?.lang || 'zh-CN'), zhVoice);
    if (!zhUtter) return resolve();
    zhUtter.onend = () => resolve();
  });
}
replayZHBtn.addEventListener('click', async () => {
  await speakChinese(currentChinese);
});
stopAllBtn.addEventListener('click', stopSpeaking);

/* ========= Status ========= */
function updateStatus(){
  let fileCount = datasets.size;
  let storyCount = 0;
  for (const ds of datasets.values()) storyCount += (ds.stories?.length || 0);
  statusPill.textContent = `${fileCount} file${fileCount!==1?'s':''} â€¢ ${storyCount} stor${storyCount===1?'y':'ies'}`;
}

/* ========= Init ========= */
updateFileSelector();
updateStatus();
</script>
</body>
</html>
