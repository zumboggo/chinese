<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Parallel Text Reader</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --bg:#111; --fg:#fff; --muted:#999; --accent:#3b82f6; }
    * { box-sizing:border-box; }
    body {
      margin:0; font-family:system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, Noto Sans, "Apple Color Emoji","Segoe UI Emoji";
      background:var(--bg); color:var(--fg); display:flex; flex-direction:column; height:100vh;
    }
    .row { display:flex; gap:8px; }
    .inputs { height:34vh; padding:8px; }
    textarea {
      flex:1; padding:12px; font-size:16px; resize:none; border-radius:10px; border:1px solid #333; background:#0a0a0a; color:var(--fg);
    }
    .controls {
      padding:10px 12px; border-block:1px solid #222; background:#161616; display:flex; flex-wrap:wrap; gap:12px; align-items:center;
    }
    .controls label { font-size:14px; color:var(--muted); display:flex; align-items:center; gap:8px; }
    .controls input[type="range"] { width:160px; }
    .controls select, .controls button { font-size:14px; }
    button {
      background:var(--accent); color:white; border:none; border-radius:10px; padding:10px 14px; cursor:pointer;
      box-shadow:0 2px 10px rgba(0,0,0,.25);
    }
    button.secondary { background:#2b2b2b; }
    button:disabled { opacity:.6; cursor:not-allowed; }
    .display { flex:1; overflow:hidden; padding:8px; }
    .panel {
      flex:1; position:relative; overflow:hidden; border:1px solid #222; border-radius:12px; padding:18px; background:#0a0a0a;
      font-size:24px; line-height:1.8;
    }
    .panel h3 { position:absolute; top:8px; right:12px; margin:0; font-size:13px; color:#bbb; font-weight:600; letter-spacing:.03em; }
    .scroll-text {
      position:absolute; left:0; width:100%;
      transform:translateY(0px); white-space:pre-wrap; word-break:break-word;
    }
    .muted { color:var(--muted); font-size:12px; }
    .stack { display:flex; flex-direction:column; gap:6px; }
  </style>
</head>
<body>
  <div class="row inputs">
    <textarea id="chineseInput" placeholder="粘贴中文在这里…（支持汉字）"></textarea>
    <textarea id="englishInput" placeholder="Paste English here…"></textarea>
  </div>

  <div class="controls">
    <button id="startBtn">▶ Start</button>
    <button id="pauseBtn" class="secondary" disabled>⏸︎ Pause</button>
    <button id="resumeBtn" class="secondary" disabled>▶ Resume</button>
    <button id="stopBtn" class="secondary" disabled>■ Stop</button>

    <label><input type="checkbox" id="autoSync" checked /> Auto-Sync to Voice</label>

    <label>Scroll Speed
      <input type="range" id="scrollSpeed" min="40" max="400" step="10" value="120" />
      <span class="muted">px/sec</span>
    </label>

    <label>Voice Speed
      <input type="range" id="voiceSpeed" min="0.6" max="1.4" step="0.05" value="0.9" />
    </label>

    <label>Chinese Voice
      <select id="voiceSelect"></select>
    </label>
    <span id="tips" class="muted"></span>
  </div>

  <div class="row display">
    <div class="panel" id="chPanel">
      <h3>中文</h3>
      <div class="scroll-text" id="chText"></div>
    </div>
    <div class="panel" id="enPanel">
      <h3>English</h3>
      <div class="scroll-text" id="enText"></div>
    </div>
  </div>

  <script>
    // Elements
    const startBtn = document.getElementById('startBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const resumeBtn = document.getElementById('resumeBtn');
    const stopBtn = document.getElementById('stopBtn');
    const autoSyncEl = document.getElementById('autoSync');
    const scrollSpeedEl = document.getElementById('scrollSpeed');
    const voiceSpeedEl = document.getElementById('voiceSpeed');
    const voiceSelect = document.getElementById('voiceSelect');
    const tips = document.getElementById('tips');

    const chineseInput = document.getElementById('chineseInput');
    const englishInput = document.getElementById('englishInput');
    const chPanel = document.getElementById('chPanel');
    const enPanel = document.getElementById('enPanel');
    const chText = document.getElementById('chText');
    const enText = document.getElementById('enText');

    let rafId = null;
    let playing = false;
    let utterance = null;
    let voices = [];
    let hasBoundary = false;

    // Geometry for scrolling
    let startY_ch = 0, endY_ch = 0, startY_en = 0, endY_en = 0;
    function measureAndReset() {
      chText.textContent = chineseInput.value.trim();
      enText.textContent = englishInput.value.trim();

      // Start below the visible area (like a teleprompter)
      const chH = chText.scrollHeight;
      const enH = enText.scrollHeight;
      const chPanelH = chPanel.clientHeight;
      const enPanelH = enPanel.clientHeight;

      startY_ch = chPanelH;         // start just below
      endY_ch   = -chH - 24;        // fully scrolled out
      startY_en = enPanelH;
      endY_en   = -enH - 24;

      setScrollFraction(0); // reset to start
    }

    function setScrollFraction(f) {
      // Clamp
      f = Math.max(0, Math.min(1, f));
      const yCh = startY_ch + (endY_ch - startY_ch) * f;
      const yEn = startY_en + (endY_en - startY_en) * f;
      chText.style.transform = `translateY(${yCh}px)`;
      enText.style.transform = `translateY(${yEn}px)`;
    }

    // Manual animation when Auto-Sync is OFF
    let lastTs = 0;
    let progress = 0; // 0..1
    function animateManual(ts) {
      if (!playing) return;
      if (!lastTs) lastTs = ts;
      const dt = (ts - lastTs) / 1000; // seconds
      lastTs = ts;

      const speed = parseFloat(scrollSpeedEl.value); // px/sec
      const distance = (startY_ch - endY_ch);        // total px to travel
      const df = (speed / distance) * dt;
      progress += df;
      setScrollFraction(progress);

      if (progress >= 1) {
        stopAll();
        return;
      }
      rafId = requestAnimationFrame(animateManual);
    }

    // Auto-Sync: follow TTS progress via boundary events.
    let totalChars = 0;
    let lastFraction = 0;
    function bindBoundarySync() {
      if (!utterance) return;
      totalChars = (chineseInput.value || '').length || 1;
      lastFraction = 0;
      hasBoundary = false;

      utterance.onboundary = (e) => {
        // Some browsers fire for words/phrases; we use charIndex
        if (typeof e.charIndex === 'number') {
          hasBoundary = true;
          lastFraction = Math.min(1, e.charIndex / totalChars);
          setScrollFraction(lastFraction);
        }
      };
      // Fallback smoother tick in case boundary is sparse
      function gentleFollower() {
        if (!playing || autoSyncEl.checked === false) return;
        // Nudge a tiny bit forward to keep things smooth between boundaries
        setScrollFraction(lastFraction);
        rafId = requestAnimationFrame(gentleFollower);
      }
      rafId = requestAnimationFrame(gentleFollower);
    }

    function estimateDurationSec(text, rate) {
      // Heuristic: ~6.5 Chinese chars/sec at rate 1.0 (adjust as needed)
      const cleanLen = (text || '').replace(/\s+/g,'').length;
      const cps = 6.5 * rate;
      return Math.max(1, cleanLen / cps);
    }

    // TTS setup
    function loadVoices() {
      voices = speechSynthesis.getVoices();
      voiceSelect.innerHTML = '';
      const zhVoices = voices.filter(v => /(^zh)|zh-|cmn|Hans|Chinese/i.test(v.lang + ' ' + v.name));
      const all = zhVoices.length ? zhVoices : voices;
      all.forEach((v, i) => {
        const opt = document.createElement('option');
        opt.value = v.name;
        opt.textContent = `${v.name} (${v.lang})`;
        voiceSelect.appendChild(opt);
      });
      if (!zhVoices.length) {
        tips.textContent = 'No dedicated Chinese voice detected. Your browser may still read Chinese.';
      } else {
        tips.textContent = '';
      }
    }
    speechSynthesis.onvoiceschanged = loadVoices;
    loadVoices();

    function pickVoice() {
      const wanted = voiceSelect.value;
      return voices.find(v => v.name === wanted) ||
             voices.find(v => /(^zh)|zh-|cmn|Hans|Chinese/i.test(v.lang + ' ' + v.name)) ||
             voices[0] || null;
    }

    // Controls
    startBtn.addEventListener('click', () => {
      if (!chineseInput.value.trim()) {
        alert('Please paste some Chinese text.');
        return;
      }
      measureAndReset();
      startAll();
    });

    pauseBtn.addEventListener('click', () => {
      if (!playing) return;
      speechSynthesis.pause();
      pauseBtn.disabled = true;
      resumeBtn.disabled = false;
    });

    resumeBtn.addEventListener('click', () => {
      speechSynthesis.resume();
      pauseBtn.disabled = false;
      resumeBtn.disabled = true;
    });

    stopBtn.addEventListener('click', stopAll);

    function startAll() {
      // Buttons
      startBtn.disabled = true;
      pauseBtn.disabled = false;
      resumeBtn.disabled = true;
      stopBtn.disabled = false;

      // Prepare TTS
      utterance = new SpeechSynthesisUtterance(chineseInput.value);
      utterance.lang = 'zh-CN';
      utterance.rate = parseFloat(voiceSpeedEl.value);
      utterance.pitch = 1;
      const voice = pickVoice();
      if (voice) utterance.voice = voice;

      // Reset state
      playing = true;
      progress = 0;
      lastTs = 0;
      cancelAnimationFrame(rafId);
      speechSynthesis.cancel();

      // Sync mode
      if (autoSyncEl.checked) {
        bindBoundarySync();
      } else {
        rafId = requestAnimationFrame(animateManual);
      }

      // Start speaking
      const t0 = performance.now();
      const expected = autoSyncEl.checked ? estimateDurationSec(chineseInput.value, utterance.rate) : null;

      utterance.onstart = () => {
        // If Auto-Sync but boundary events never arrive, use a duration estimate as fallback
        if (autoSyncEl.checked && !hasBoundary) {
          let localStart = performance.now();
          function fallbackTimer(ts) {
            if (!playing || autoSyncEl.checked === false) return;
            const elapsed = (ts - localStart) / 1000;
            const f = Math.min(1, elapsed / expected);
            setScrollFraction(f);
            rafId = requestAnimationFrame(fallbackTimer);
          }
          rafId = requestAnimationFrame(fallbackTimer);
        }
      };

      utterance.onend = () => {
        setScrollFraction(1);
        stopAll(true);
      };

      utterance.onerror = (e) => {
        alert('Speech synthesis error: ' + (e.error || 'unknown'));
        stopAll();
      };

      speechSynthesis.speak(utterance);
    }

    function stopAll(skipCancel=false) {
      playing = false;
      cancelAnimationFrame(rafId);
      if (!skipCancel) speechSynthesis.cancel();
      startBtn.disabled = false;
      pauseBtn.disabled = true;
      resumeBtn.disabled = true;
      stopBtn.disabled = true;
    }

    // Helpful defaults / sample text
    chineseInput.value = "在学习一门新语言时，重复朗读可以帮助你自然地掌握语感。\n配合平行文本阅读，你可以一边听中文，一边对照英文。";
    englishInput.value = "When learning a new language, repeated reading aloud helps you naturally develop a feel for it.\nWith parallel text reading, you can listen to Chinese while checking the English.";

    // Resize recalculation (handles window changes before/after start)
    window.addEventListener('resize', () => {
      if (!playing) measureAndReset();
    });
  </script>
</body>
</html>
